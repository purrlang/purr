// nodes.pu - AST node definitions (documentation & stubs)

// AST node shapes (conceptual):
// Program := { namespace: NamespaceDecl, uses: [UseDecl], declarations: [Declaration] }
// NamespaceDecl := { name: string }
// UseDecl := { name: string, alias: string? }
// Declaration := StructDecl | EnumDecl | InterfaceDecl | ActorDecl | FunctionDecl
// StructDecl := { name: string, fields: [{ name: string, type: Type }] }
// EnumDecl := { name: string, cases: [{ name: string, fields: [{ name, type }]? }] }
// InterfaceDecl := { name: string, methods: [MethodSig] }
// MethodSig := { name: string, params: [{ name, type }], ret: Type }
// ActorDecl := { name: string, fields: [{ name, type }], handlers: [OnHandler] }
// OnHandler := { name: string, params: [{ name, type }], ret: Type, body: Block }
// FunctionDecl := { name: string, is_method: bool, type_name: string?, params: [{name, type}], ret: Type, body: Block }
// Block := { statements: [Statement] }
// VarDecl := { name: string, type: Type, init: Expression }
// AssignStmt := { target: LValue, value: Expression }
// IfStmt := { cond: Expression, then: Block, else: Block? }
// ForStmt := { init: ForInit?, cond: Expression?, step: ForStep?, body: Block }
// SwitchStmt := { value: Expression, cases: [CaseClause], else: Block? }
// ReturnStmt := { value: Expression? }
// Expression: many forms (literals, binary ops, function call, struct literal, enum case, field access, spawn)

// In code we will implement constructors and helpers to create these nodes.
